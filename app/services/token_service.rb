# frozen_string_literal: true

require 'jwt'
require 'httparty'

#
# Service to crate and verify JWTs
#
module TokenService
  class << self
    #
    # Generate new token
    #
    # @param [Login] login Login object for authenticating user.
    #
    # @return [String] Encrypted token with authenticating user's info.
    #
    def create(login)
      exp = Time.now.to_i + 4 * 3600
      exp_payload = { data: { who: login.who }, exp: exp }
      JWT.encode exp_payload,
                 Rails.application.credentials[:secret_key_base],
                 'HS256'
    end

    #
    # Verifies a token was generated by this application by decoding it.
    #
    # @param [String] token to be verified
    #
    # @return [Boolean, Array] Returns `false` if token is expired or invalid.
    #                          Otherwise, returns the contents of the token.
    #
    def verify(token)
      key = Rails.application.credentials[:secret_key_base]
      begin
        contents = JWT.decode token, key, true, algorithm: 'HS256'
      rescue JWT::ExpiredSignature
        retun false # Handle expired token, e.g. logout user and/or deny access
      rescue JWT::VerificationError
        # Handle invalid token, e.g. logout user and/or deny access
        return false
      end
      contents
    end

    def verify_remote(params)
      remote_url = "https://#{EcdsRailsAuthEngine.verification_host}/tokens"
      response = HTTParty.post(generate_url(remote_url, access_token: params)).parsed_response
      if response.is_a?(String)
        YAML.load(response).symbolize_keys!
      else
        Rails.logger.debug "Faux OAuth response: #{response}"
        response[0]['data'].symbolize_keys!
      end
    end

    private

    def generate_url(url, params = {})
      uri = URI(url)
      uri.query = params.to_query
      uri.to_s
    end
  end
end
